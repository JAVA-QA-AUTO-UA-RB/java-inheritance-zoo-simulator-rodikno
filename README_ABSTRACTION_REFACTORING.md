---

# 🦁 Домашнє завдання: Система управління зоопарком - Абстракція та Інтерфейси 🐘

---

Вітаємо у другому етапі створення системи управління зоопарком! 🎉 На цьому етапі ви вдосконалите свою ієрархію, застосувавши принципи **абстракції** та **інтерфейсів**, які ми щойно вивчили. Це дозволить зробити вашу систему більш гнучкою, розширюваною та відповідною стандартам об'єктно-орієнтованого програмування.

## 📋 Опис завдання

Ваше завдання - переробити існуючу ієрархію класів тварин, перетворивши базові класи на **абстрактні** та додавши **інтерфейси** для опису спільних поведінок.

### 🎯 Цілі завдання:
- Закріпити розуміння **абстрактних класів** та **абстрактних методів**.
- Навчитися правильно використовувати **інтерфейси** для опису поведінки.
- Поглибити розуміння принципів **ООП** (абстракція, поліморфізм).
- Зробити код більш гнучким та легким для розширення.

## 📦 Структура пакетів

Структура пакетів залишається тією ж, але тепер ви будете змінювати вміст існуючих файлів та, можливо, додавати нові інтерфейси.

```
src/
└── main/
    └── java/
        └── com/
            └── zoo/
                ├── animals/          # Базові класи тварин
                │   ├── Animal.java
                │   ├── Mammal.java
                │   └── Bird.java
                ├── species/          # Конкретні види тварин
                │   ├── Lion.java
                │   ├── Elephant.java
                │   ├── Eagle.java
                │   └── Penguin.java
                ├── zookeeper/        # Класи працівників
                │   └── ZooKeeper.java
                └── ZooSimulator.java  # Головний клас
```

## 📝 Вимоги до реалізації

### 1. 🐾 Перетворення `Animal` на Абстрактний Клас

Зробіть клас `Animal` максимально **абстрактним**.

- Клас `Animal` має містити лише поля `name` та `energyLevel`.
- Клас `Animal` повинен реалізовувати інтерфейси `IEatable` та `ISleepable`.
- Метод `public abstract void makeSound()` тепер має бути **публічним та абстрактним** у класі `Animal`.
- Методи `public abstract void eat()` та `public abstract void sleep()`, успадковані від інтерфейсів, також мають бути **абстрактними** в класі `Animal`. Це делегує їх реалізацію до конкретних класів.

### 2. 🦌 Перетворення `Mammal` та `Bird` на Абстрактні Класи

Перетворіть класи `Mammal` та `Bird` на **абстрактні**.

- Ці класи повинні успадковувати всі абстрактні методи від `Animal`, але *не* реалізовувати методи інтерфейсів (`eat()` та `sleep()`).
- Додайте абстрактні методи в `Mammal` та `Bird` для поведінок, які є спільними для всіх ссавців/птахів, але мають специфічну реалізацію для кожного виду. Наприклад:
    - У `Mammal`: абстрактний метод `void move()` (рух).
    - У `Bird`: абстрактний метод `void uniqueBirdAction()` (унікальна дія для птахів, далі конкретний птах буде викликати в ньому власний приватний метод властивий тільки цьому виду птахів наприклад, `buildNest()` або `sing()`).

### 3. 🌐 Створення Інтерфейсів

Створіть декілька інтерфейсів для опису спільних поведінок, які можуть бути реалізовані різними тваринами, незалежно від їхньої ієрархії спадкування.

- Створіть інтерфейс `IEatable` з методом `void eat()`.
- Створіть інтерфейс `ISleepable` з методом `void sleep()`.
- Створіть інтерфейс `IPlayable` з методом `void play()`.

### 4. 🔗 Застосування Інтерфейсів

Застосуйте створені інтерфейси до відповідних класів:

- Клас `Animal` реалізовує `IEatable` та `ISleepable`, і оголошує їхні методи **абстрактними**.
- Клас `ZooKeeper` має використовувати методи з цих інтерфейсів для взаємодії з тваринами. Наприклад, `feedAnimal(IEatable animal)` та `playWithAnimal(IPlayable animal)`.
- **Важливо:** Інтерфейс `IPlayable` має бути реалізований **безпосередньо в конкретних класах** тварин (`Lion`, `Elephant`, `Eagle`, `Penguin`), а не в абстрактних батьківських класах.

### 5. 🦁 Оновлення Конкретних Тварин

Переконайтеся, що всі конкретні класи тварин (`Lion`, `Elephant`, `Eagle`, `Penguin`) коректно:

- Наслідують від оновлених абстрактних класів (`Mammal` або `Bird`).
- **Імплементують усі абстрактні методи**:
    - Успадковані від `Animal` (`makeSound()`, `eat()`, `sleep()`).
    - Успадковані від `Mammal` або `Bird` (`move()` або `uniqueBirdAction()`).
    - Реалізовують метод `play()` з інтерфейсу `IPlayable`.
- Приклади реалізацій:
    - **Lion**: `move()` - "Lion runs swiftly."
    - **Elephant**: `move()` - "Elephant stomps heavily."
    - **Eagle**: `uniqueBirdAction()` - викликає приватний метод `buildNest()`
    - **Penguin**: `uniqueBirdAction()` - викликає приватний метод `surfOnIce()`

### 6. 👨‍🔬 Оновлення Класу `ZooKeeper`

- Оновіть методи `feedAnimal`, `playWithAnimal` та `checkAnimalEnergyLevel` так, щоб вони використовували інтерфейси, де це доречно, замість конкретного класу `Animal`. Це продемонструє поліморфізм та гнучкість.
    - `public void feedAnimal(IEatable animal)`
    - `public void playWithAnimal(IPlayable animal)`
    - `public void checkAnimalEnergyLevel(Animal animal)` (тут Animal залишається, оскільки енергія - це внутрішня властивість базового класу)

### 7. 🎮 Оновлення Класу `ZooSimulator`

- Переконайтеся, що `ZooSimulator` все ще створює та взаємодіє з тваринами, використовуючи нову ієрархію та інтерфейси.
- Продемонструйте використання поліморфізму підтипів: створіть масив (або список) типу `Animal` або `IPlayable`, додайте туди конкретні об'єкти класів, що є наслідниками та/або імплементаторами абстракцій і пройдіться по ньому, викликаючи методи, властиві абстрактному класу чи інтерфейсу. Таким чином ми переконуємося, що можна заздалегідь очікувати щось більш абстрактне, а потім передавати конкретного представника і наша логіка не ламається.

## ✅ Критерії оцінювання

- ✨ Правильне використання ключового слова `abstract` для класів та методів.
- 🔗 Коректне визначення та реалізація **інтерфейсів**.
- 🔒 Збереження коректних модифікаторів доступу.
- 📦 Правильна організація пакетів.
- 🔄 Використання `super` в конструкторах та методах, де це необхідно.
- 🎯 Перевизначення методів (`@Override`) для абстрактних методів та методів інтерфейсів.
- 🎮 Демонстрація **поліморфізму** у `ZooSimulator` та `ZooKeeper`.
- 📖 Читабельність та документування коду.

## 🤝 Як здавати завдання

0. Створіть у вашому проєкті с Зоопарком нову бранчу `abstract_rework`, відбранчувавшись з `main` після того, як там було правильно виконане попереднє завдання
1. Реалізуйте всі зміни в існуючих класах згідно з вимогами.
2. Переконайтеся, що код компілюється та працює без помилок.
3. Комітьте та пуште ваші зміни у гілку `abstract_rework`.
4. Коли вважаєте рефакторинг доробленим - самостійно створіть ПР `abstract_rework` -> `main` (ВАЖЛИВО: ДЖЕРЕЛО `abstract_rework`, В НАПРЯМКУ `main`, тільки так в ПР потраплять ваші нові зміни)
5. Після завершення виконання - додайте відмітьте домашку в Google Classroom зробленою та додайте приватний коментар з посиланням на новий пул реквест з вашого репозиторію.

### Будь-ласка, називайте ваші пул реквести по суті - ніяких "Please approve", "Done", "HW completed" і т.п. - назва ПРу і його опис повинні містити чіткий опис того, що в ньому було зроблено, тайтл має бути коротким в один рядок, дексріпшн може бути розгорнутим

**Удачі в програмуванні! 🌟 Нехай ваш зоопарк стане зразком об'єктно-орієнтованого дизайну! 🎊**

---
*💡 Пам'ятайте: Абстракція дозволяє нам зосередитись на "що" об'єкт робить, а не на "як" він це робить, тоді як інтерфейси визначають контракт поведінки!*
